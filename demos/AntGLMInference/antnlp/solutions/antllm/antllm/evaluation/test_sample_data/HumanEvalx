{"task_id": "CPP/0", "predictions": [""], "references": [""], "prompt": "/*\nCheck if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n*/\n#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\nbool has_close_elements(vector<float> numbers, float threshold){\n", "canonical_solution": "    int i,j;\n    \n    for (i=0;i<numbers.size();i++)\n    for (j=i+1;j<numbers.size();j++)\n    if (abs(numbers[i]-numbers[j])<threshold)\n    return true;\n\n    return false;\n}\n\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    vector<float> a={1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert (has_close_elements(a, 0.3)==true);\n    assert (has_close_elements(a, 0.05) == false);\n\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.95) == true);\n    assert (has_close_elements({1.0, 2.0, 5.9, 4.0, 5.0}, 0.8) ==false);\n    assert (has_close_elements({1.0, 2.0, 3.0, 4.0, 5.0}, 2.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0) == true);\n    assert (has_close_elements({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5) == false);\n    \n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nbool has_close_elements(vector<float> numbers, float threshold){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (has_close_elements({1.0, 2.0, 3.0}, 0.5) == false && \"failure 1\");\n    assert (has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3) && \"failure 2\") ;\n}\n", "func_title": "bool has_close_elements(vector<float> numbers, float threshold)", "prompt_text": "Check if in given vector of numbers, are any two numbers closer to each other than given threshold.", "prompt_explain": "Check if in given vector of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements({1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> has_close_elements({1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue", "prediction": "     for(int i = 0; i < numbers.size(); i++){\n         float diff = fabs(numbers[i] - numbers[i-1]);\n         if(diff < threshold){\n             return true;\n         }\n     }\n     return false;\n }"}
{"task_id": "CPP/1", "predictions": [""], "references": [""], "prompt": "/*\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the vector of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> separate_paren_groups(string paren_string){\n", "canonical_solution": "    vector<string> all_parens;\n    string current_paren;\n    int level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_parens.push_back(current_paren);\n                current_paren=\"\";\n            }\n        }\n    }\n    return all_parens;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"(()()) ((())) () ((())()())\"),{\"(()())\", \"((()))\", \"()\", \"((())()())\"}));\n    assert (issame(separate_paren_groups(\"() (()) ((())) (((())))\"), {\"()\", \"(())\", \"((()))\", \"(((())))\" }));\n    assert (issame(separate_paren_groups(\"(()(())((())))\") ,{ \"(()(())((())))\" }));\n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> separate_paren_groups(string paren_string){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){  \n    assert (issame(separate_paren_groups(\"( ) (( )) (( )( ))\") ,{\"()\", \"(())\", \"(()())\"}));\n}\n", "func_title": "vector<string> separate_paren_groups(string paren_string)", "prompt_text": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the vector of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.", "prompt_explain": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the vector of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n{\"()\", \"(())\", \"(()())\"}", "prediction": " vector<string> result;\n string current_group;\n\n // initialize current_group to empty string\n current_group = \"\";\n\n // iterate through the input string\n for (int i = 0; i < paren_string.length(); i++) {\n     // if the current character is a space, skip it\n     if (paren_string[i] =='') {\n         continue;\n     }\n\n     // if the current character is a closing brace, add it to the current_group\n     if (paren_string[i] == ')') {\n         current_group += paren_string[i + 1];\n     }\n\n     // if the current character is an opening brace, add it to the current_group\n     if (paren_string[i] == '(') {\n         current_group += paren_string[i + 1];\n     }\n }\n\n // if there is no closing brace, add an empty string to the current_group\n if (current_group.length() == 0) {\n     current_group = \"() \";\n }\n\n // add the current_group to the result vector\n result.push_back(current_group);\n\n // return the result vector\n return result;\n }"}
{"task_id": "CPP/2", "predictions": [""], "references": [""], "prompt": "/*\nGiven a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5\n*/\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nfloat truncate_number(float number){\n", "canonical_solution": "    return number-int(number);\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n assert (abs(truncate_number(1.33) - 0.33) < 1e-4);\n  assert (abs(truncate_number(123.456) - 0.456) < 1e-4);\n}", "declaration": "#include<stdio.h>\n#include<math.h>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat truncate_number(float number){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n assert (truncate_number(3.5) == 0.5); \n}\n", "func_title": "float truncate_number(float number)", "prompt_text": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.", "prompt_explain": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5", "prediction": " int intpart = floor(number);\n float decimalpart = number - intpart;\n return decimalpart;\n }"}
{"task_id": "CPP/3", "predictions": [""], "references": [""], "prompt": "/*\nYou\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nbool below_zero(vector<int> operations){\n", "canonical_solution": "    int num=0;\n    for (int i=0;i<operations.size();i++)\n    {\n        num+=operations[i];\n        if (num<0) return true;\n    }\n    return false;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({}) == false);\n    assert (below_zero({1, 2, -3, 1, 2, -3}) == false);\n    assert (below_zero({1, 2, -4, 5, 6}) == true);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -4}) == false);\n    assert (below_zero({1, -1, 2, -2, 5, -5, 4, -5}) == true);\n    assert (below_zero({1, -2, 2, -2, 5, -5, 4, -4}) == true);\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nbool below_zero(vector<int> operations){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (below_zero({1, 2, 3}) == false);\n    assert (below_zero({1, 2, -4, 5}) == true);\n}\n", "func_title": "bool below_zero(vector<int> operations)", "prompt_text": "You\"re given a vector of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account falls below zero, and at that point function should return true. Otherwise it should return false.", "prompt_explain": "You\"re given a vector of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account falls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> below_zero({1, 2, 3})\nfalse\n>>> below_zero({1, 2, -4, 5})\ntrue", "prediction": "     int balance = 0;\n     for(int i = 0; i < operations.size(); i++){\n         int amount = operations[i];\n         balance += amount;\n         if(balance < 0){\n             return true;\n         }\n     }\n     return false;\n }"}
{"task_id": "CPP/4", "predictions": [""], "references": [""], "prompt": "/*\nFor a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0\n*/\n#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\nfloat mean_absolute_deviation(vector<float> numbers){\n", "canonical_solution": "    float sum=0;\n    float avg,msum,mavg;\n    int i=0;\n    for (i=0;i<numbers.size();i++)\n        sum+=numbers[i];\n    avg=sum/numbers.size();\n    msum=0;\n    for (i=0;i<numbers.size();i++)\n        msum+=abs(numbers[i]-avg);\n    return msum/numbers.size();\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0}) - 2.0/3.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0}) - 6.0/5.0) < 1e-4);\n}", "declaration": "#include<stdio.h>\n#include<math.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<stdlib.h>\nfloat mean_absolute_deviation(vector<float> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert (abs(mean_absolute_deviation({1.0, 2.0, 3.0, 4.0}) - 1.0) < 1e-4);\n}\n", "func_title": "float mean_absolute_deviation(vector<float> numbers)", "prompt_text": "For a given vector of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |", "prompt_explain": "For a given vector of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation({1.0, 2.0, 3.0, 4.0})\n1.0", "prediction": " float mean = sum(numbers) / (float)numbers.size();\n float sum_of_absolute_differences = 0;\n for (int i = 0; i < numbers.size(); i++) {\n     float diff = abs(numbers[i] - mean);\n     sum_of_absolute_differences += diff;\n }\n float mad = sum_of_absolute_differences / (float)numbers.size();\n return mad;\n }"}
{"task_id": "CPP/5", "predictions": [""], "references": [""], "prompt": "/*\nInsert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n", "canonical_solution": "    vector<int> out={};\n    if (numbers.size()>0) out.push_back(numbers[0]);\n    for (int i=1;i<numbers.size();i++)\n    {\n        out.push_back(delimeter);\n        out.push_back(numbers[i]);\n\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 7), {}));\n    \n    assert (issame(intersperse({5, 6, 3, 2}, 8),{5, 8, 6, 8, 3, 8, 2}));\n    assert (issame(intersperse({2, 2, 2}, 2),{2, 2, 2, 2, 2}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> intersperse(vector<int> numbers, int delimeter){ \n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(intersperse({}, 4), {}));\n    assert (issame(intersperse({1, 2, 3}, 4),{1, 4, 2, 4, 3}));\n}\n", "func_title": "vector<int> intersperse(vector<int> numbers, int delimeter)", "prompt_text": "Insert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"", "prompt_explain": "Insert a number \"delimeter\" between every two consecutive elements of input vector `numbers\"\n>>> intersperse({}, 4)\n{}\n>>> intersperse({1, 2, 3}, 4)\n{1, 4, 2, 4, 3}", "prediction": "     vector<int> result;\n     for (int i = 0; i < numbers.size(); i++) {\n         if (i > 0 && numbers[i] == numbers[i - 1]) {\n             result.push_back(delimeter);\n         } else {\n             result.push_back(numbers[i]);\n         }\n         result.push_back(numbers[i + 1]);\n     }\n     return result;\n }"}
{"task_id": "CPP/6", "predictions": [""], "references": [""], "prompt": "/*\nInput to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<int> parse_nested_parens(string paren_string){\n", "canonical_solution": "    vector<int> all_levels;\n    string current_paren;\n    int level=0,max_level=0;\n    char chr;\n    int i;\n    for (i=0;i<paren_string.length();i++)\n    {\n        chr=paren_string[i];\n        if (chr=='(')\n        {\n        level+=1;\n        if (level>max_level) max_level=level;\n        current_paren+=chr;\n        }\n        if (chr==')')\n        {\n            level-=1;\n            current_paren+=chr;\n            if (level==0){\n                all_levels.push_back(max_level);\n                current_paren=\"\";\n                max_level=0;\n            }\n        }\n    }\n    return all_levels;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n     assert (issame(parse_nested_parens(\"() (()) ((())) (((())))\") , {1, 2, 3, 4}));\n    assert (issame(parse_nested_parens(\"(()(())((())))\") ,{4}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> parse_nested_parens(string paren_string){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(parse_nested_parens(\"(()()) ((())) () ((())()())\"),{2, 3, 1, 3}));\n}\n", "func_title": "vector<int> parse_nested_parens(string paren_string)", "prompt_text": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three. ", "prompt_explain": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n{2, 3, 1, 3}", "prediction": " vector<int> nested_parens;\n int level = 0;\n for(int i = 0; i < paren_string.length(); i++){\n     if(paren_string[i] == '('){\n         level++;\n     }\n     else if(paren_string[i] == ')'){\n         level--;\n     }\n     if(level == 0){\n         nested_parens.push_back(i);\n     }\n }\n return nested_parens;\n }"}
{"task_id": "CPP/7", "predictions": [""], "references": [""], "prompt": "/*\nFilter an input vector of strings only for ones that contain given substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}\n*/\n#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\nvector<string> filter_by_substring(vector<string> strings, string substring){\n", "canonical_solution": "    vector<string> out;\n    for (int i=0;i<strings.size();i++)\n    {\n        if (strings[i].find(substring)!=strings[i].npos)\n        out.push_back(strings[i]);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"john\"),{}));\n     assert (issame(filter_by_substring({\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"), {\"xxx\", \"xxxAAA\", \"xxx\"}));\n    assert (issame(filter_by_substring({\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"),{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}));\n     assert (issame(filter_by_substring({\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\") ,{\"grunt\", \"prune\"}));\n}\n", "declaration": "#include<stdio.h>\n#include<vector>\n#include<string>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<string> filter_by_substring(vector<string> strings, string substring){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<string> a,vector<string>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n    if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(filter_by_substring({}, \"a\"),{}));\n     assert (issame(filter_by_substring({\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"), {\"abc\", \"bacd\", \"array\"}));\n}\n", "func_title": "vector<string> filter_by_substring(vector<string> strings, string substring)", "prompt_text": "Filter an input vector of strings only for ones that contain given substring", "prompt_explain": "Filter an input vector of strings only for ones that contain given substring\n>>> filter_by_substring({}, \"a\")\n{}\n>>> filter_by_substring({\"abc\", \"bacd\", \"cde\", \"vector\"}, \"a\")\n{\"abc\", \"bacd\", \"vector\"}", "prediction": "     vector<string> filtered_strings;\n     for(int i = 0; i < strings.size(); i++){\n         if(strings[i].find(substring)!= string::npos){\n             filtered_strings.push_back(strings[i]);\n         }\n     }\n     return filtered_strings;\n }"}
{"task_id": "CPP/8", "predictions": [""], "references": [""], "prompt": "/*\nFor a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> sum_product(vector<int> numbers){\n", "canonical_solution": "    int sum=0,product=1;\n    for (int i=0;i<numbers.size();i++)\n    {\n        sum+=numbers[i];\n        product*=numbers[i];\n    }\n    return {sum,product};\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 1, 1}), {3, 1}));\n    assert (issame(sum_product({100, 0}),{100, 0}));\n     assert (issame(sum_product({3, 5, 7}) , {3 + 5 + 7, 3 * 5 * 7}));\n      assert (issame(sum_product({10}) ,{10, 10}));\n}\n\n\n", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> sum_product(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n    assert (issame(sum_product({}) ,{0, 1}));\n    assert (issame(sum_product({1, 2, 3,4}), {10, 24}));\n}\n", "func_title": "vector<int> sum_product(vector<int> numbers)", "prompt_text": "For a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector. Empty sum should be equal to 0 and empty product should be equal to 1.", "prompt_explain": "For a given vector of integers, return a vector consisting of a sum and a product of all the integers in a vector.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sum_product({})\n(0, 1)\n>>> sum_product({1, 2, 3, 4})\n(10, 24)", "prediction": " vector<int> sum = {0};\n vector<int> product = {1};\n for(int i = 0; i < numbers.size(); i++){\n     sum[numbers[i]] += 1;\n     product[numbers[i]] *= numbers[i];\n }\n return {sum, product};"}
{"task_id": "CPP/9", "predictions": [""], "references": [""], "prompt": "/*\nFrom a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}\n*/\n#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> rolling_max(vector<int> numbers){\n", "canonical_solution": "    vector<int> out;\n    int max=0;\n    for (int i=0;i<numbers.size();i++)\n    {\n        if (numbers[i]>max) max=numbers[i];\n        out.push_back(max);\n    }\n    return out;\n}\n", "test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({}),{}));\n    assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));\n     assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));\n      assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));\n}", "declaration": "#include<stdio.h>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\nvector<int> rolling_max(vector<int> numbers){\n", "example_test": "#undef NDEBUG\n#include<assert.h>\nbool issame(vector<int> a,vector<int>b){\n    if (a.size()!=b.size()) return false;\n    for (int i=0;i<a.size();i++)\n    {\n        if (a[i]!=b[i]) return false;\n    }\n    return true;\n}\nint main(){\n     assert (issame(rolling_max({1, 2, 3, 2, 3, 4, 2}),{1, 2, 3, 3, 3, 4, 4}));\n}\n", "func_title": "vector<int> rolling_max(vector<int> numbers)", "prompt_text": "From a given vector of integers, generate a vector of rolling maximum element found until given moment in the sequence.", "prompt_explain": "From a given vector of integers, generate a vector of rolling maximum element found until given moment\nin the sequence.\n>>> rolling_max({1, 2, 3, 2, 3, 4, 2})\n{1, 2, 3, 3, 3, 4, 4}", "prediction": "     vector<int> result;\n     int current_max = numbers[0];\n     for(int i = 1; i < numbers.size(); i++){\n         if(numbers[i] > current_max){\n             current_max = numbers[i];\n             result.push_back(current_max);\n         }\n     }\n     return result;\n }"}
{"task_id": "Java/0", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n", "canonical_solution": "        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double distance = Math.abs(numbers.get(i) - numbers.get(j));\n                if (distance < threshold) return true;\n            }\n        }\n        return false;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(11.0, 2.0, 3.9, 4.0, 5.0, 2.2)), 0.3),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), 0.05),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0)), 0.95),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0)), 0.8),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), 0.1),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1)), 1.0),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1)), 0.5)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0)), 0.5),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0)), 0.3)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.", "prompt_explain": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n>>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\nfalse\n>>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\ntrue", "func_title": "public boolean hasCloseElements(List<Double> numbers, double threshold) ", "prediction": "         if (numbers == null || numbers.isEmpty()) {\n             return false;\n         }\n        \n         // Initialize the min and max values\n         double min = numbers.get(0);\n         double max = numbers.get(numbers.size() - 1);\n        \n         // Iterate through the list\n         for (int i = 1; i < numbers.size(); i++) {\n             // Calculate the difference between the current and the next element\n             double diff = max - min;\n             \n             // Check if the difference is less than the threshold\n             if (diff < threshold) {\n                 // If so, update the min and max values\n                 min = numbers.get(i);\n                 max = numbers.get(i);\n             }\n         }\n        \n         // Return the result\n         return min!= max;\n     }\n }"}
{"task_id": "Java/1", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separateParenGroups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n     */\n    public List<String> separateParenGroups(String paren_string) {\n", "canonical_solution": "        List<String> result = new ArrayList<>();\n        StringBuilder current_string = new StringBuilder();\n        int current_depth = 0;\n\n        for (char c : paren_string.toCharArray()) {\n            if (c == '(') {\n                current_depth += 1;\n                current_string.append(c);\n            } else if (c == ')') {\n                current_depth -= 1;\n                current_string.append(c);\n\n                if (current_depth == 0) {\n                    result.add(current_string.toString());\n                    current_string.setLength(0);\n                }\n            }\n        }\n        return result;\n\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.separateParenGroups(\"(()()) ((())) () ((())()())\").equals(Arrays.asList(\n                        \"(()())\", \"((()))\", \"()\", \"((())()())\"\n                )),\n                s.separateParenGroups(\"() (()) ((())) (((())))\").equals(Arrays.asList(\n                        \"()\", \"(())\", \"((()))\", \"(((())))\"\n                )),\n                s.separateParenGroups(\"(()(())((())))\").equals(Arrays.asList(\n                        \"(()(())((())))\"\n                )),\n                s.separateParenGroups(\"( ) (( )) (( )( ))\").equals(Arrays.asList(\"()\", \"(())\", \"(()())\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separateParenGroups(\"( ) (( )) (( )( ))\")\n    [\"()\", \"(())\", \"(()())\"]", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> separateParenGroups(String paren_string) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.separateParenGroups(\"( ) (( )) (( )( ))\").equals(Arrays.asList(\"()\", \"(())\", \"(()())\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.", "prompt_explain": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separateParenGroups(\"( ) (( )) (( )( ))\")\n[\"()\", \"(())\", \"(()())\"]", "func_title": "public List<String> separateParenGroups(String paren_string) ", "prediction": "         List<String> result = new ArrayList<>();\n         String current_group = \"\";\n         for (int i = 0; i < paren_string.length(); i++) {\n             char c = paren_string.charAt(i);\n             if (c == '(') {\n                 current_group += c;\n             } else if (c == ')') {\n                 if (current_group.isEmpty()) {\n                     result.add(current_group);\n                     current_group = \"\";\n                 } else {\n                     current_group += c;\n                 }\n             } else {\n                 current_group += c;\n             }\n         }\n         if (!current_group.isEmpty()) {\n             result.add(current_group);\n         }\n         return result;\n     }\n }"}
{"task_id": "Java/2", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncateNumber(3.5)\n    0.5\n     */\n    public double truncateNumber(double number) {\n", "canonical_solution": "        return number % 1.0;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n            s.truncateNumber(3.5) == 0.5,\n            Math.abs(s.truncateNumber(1.33) - 0.33) < 1e-6,\n            Math.abs(s.truncateNumber(123.456) - 0.456) < 1e-6\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncateNumber(3.5)\n    0.5", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double truncateNumber(double number) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n            s.truncateNumber(3.5) == 0.5\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.", "prompt_explain": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncateNumber(3.5)\n0.5", "func_title": "public double truncateNumber(double number) ", "prediction": "         int num = Math.abs(number);\n         int dec = num - (num % 10);\n         return dec;\n     }"}
{"task_id": "Java/3", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> belowZero(Arrays.asList(1, 2, 3))\n    false\n    >>> belowZero(Arrays.asList(1, 2, -4, 5))\n    true\n     */\n    public boolean belowZero(List<Integer> operations) {\n", "canonical_solution": "        int balance = 0;\n\n        for (int op : operations) {\n            balance += op;\n            if (balance < 0) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.belowZero(new ArrayList<>(Arrays.asList())),\n                !s.belowZero(new ArrayList<>(Arrays.asList(1, 2, -3, 1, 2, -3))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, 2, -4, 5, 6))),\n                !s.belowZero(new ArrayList<>(Arrays.asList(1, -1, 2, -2, 5, -5, 4, -4))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, -1, 2, -2, 5, -5, 4, -5))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, -2, 2, -2, 5, -5, 4, -4)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> belowZero(Arrays.asList(1, 2, 3))\n    false\n    >>> belowZero(Arrays.asList(1, 2, -4, 5))\n    true", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean belowZero(List<Integer> operations) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.belowZero(new ArrayList<>(Arrays.asList(1, 2, 3))),\n                s.belowZero(new ArrayList<>(Arrays.asList(1, 2, -4, 5)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.", "prompt_explain": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> belowZero(Arrays.asList(1, 2, 3))\nfalse\n>>> belowZero(Arrays.asList(1, 2, -4, 5))\ntrue", "func_title": "public boolean belowZero(List<Integer> operations) ", "prediction": "         int balance = 0;\n         for (int i = 0; i < operations.size(); i++) {\n             int operation = operations.get(i);\n             if (operation == 1) {\n                 balance += operations.get(i + 1);\n             } else if (operation == -1) {\n                 balance -= operations.get(i + 1);\n             } else {\n                 return true;\n             }\n         }\n         return balance < 0;\n     }"}
{"task_id": "Java/4", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> meanAbsoluteDeviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0\n     */\n    public double meanAbsoluteDeviation(List<Double> numbers) {\n", "canonical_solution": "        double sum = 0.0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        double mean = sum / numbers.size();\n        double sum_abs_diff = 0.0;\n        for (double num : numbers) {\n            sum_abs_diff += Math.abs(num - mean);\n        }\n        return sum_abs_diff / numbers.size();\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0))) - 2.0/3.0) < 1e-6,\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0))) - 1.0) < 1e-6,\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0))) - 6.0/5.0) < 1e-6\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> meanAbsoluteDeviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n    1.0", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public double meanAbsoluteDeviation(List<Double> numbers) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Math.abs(s.meanAbsoluteDeviation(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0))) - 1.0) < 1e-6\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |", "prompt_explain": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> meanAbsoluteDeviation(Arrays.asList(1.0, 2.0, 3.0, 4.0))\n1.0", "func_title": "public double meanAbsoluteDeviation(List<Double> numbers) ", "prediction": "         double sum = 0;\n         for (int i = 0; i < numbers.size(); i++) {\n             sum += Math.abs(numbers.get(i) - numbers.get(numbers.size() - 1));\n         }\n         return sum / (numbers.size() - 1);\n     }\n}"}
{"task_id": "Java/5", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n", "canonical_solution": "        if (numbers.size() == 0) {\n            return List.of();\n        }\n        List<Integer> result = new ArrayList<>(List.of());\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            result.add(numbers.get(i));\n            result.add(delimiter);\n        }\n\n        result.add(numbers.get(numbers.size() - 1));\n\n        return result;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.intersperse(new ArrayList<>(List.of()), 7).equals(List.of()),\n                s.intersperse(new ArrayList<>(Arrays.asList(5, 6, 3, 2)), 8).equals(Arrays.asList(5, 8, 6, 8, 3, 8, 2)),\n                s.intersperse(new ArrayList<>(Arrays.asList(2, 2, 2)), 2).equals(Arrays.asList(2, 2, 2, 2, 2))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.intersperse(new ArrayList<>(List.of()), 4).equals(List.of()),\n                s.intersperse(new ArrayList<>(Arrays.asList(1,2,3)), 4).equals(Arrays.asList(1,4,2,4,3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'", "prompt_explain": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n>>> intersperse(List.of(), 4)\n[]\n>>> intersperse(Arrays.asList(1, 2, 3), 4)\n[1, 4, 2, 4, 3]", "func_title": "public List<Integer> intersperse(List<Integer> numbers, int delimiter) ", "prediction": "         if (numbers == null || numbers.isEmpty()) {\n             return numbers;\n         }\n         int n = numbers.size();\n         List<Integer> result = new ArrayList<>(n);\n         for (int i = 0; i < n; i++) {\n             int index = i * 2 + 1;\n             result.set(index, numbers.get(i));\n             result.set(index + 1, numbers.get(i + 1));\n         }\n         return result;\n     }"}
{"task_id": "Java/6", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parseNestedParens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]\n     */\n    public List<Integer> parseNestedParens(String paren_string) {\n", "canonical_solution": "        String[] groups = paren_string.split(\" \");\n        List<Integer> result = new ArrayList<>(List.of());\n        for (String group : groups) {\n            if (group.length() > 0) {\n                int depth = 0;\n                int max_depth = 0;\n                for (char c : group.toCharArray()) {\n                    if (c == '(') {\n                        depth += 1;\n                        max_depth = Math.max(depth, max_depth);\n                    } else {\n                        depth -= 1;\n                    }\n                }\n                result.add(max_depth);\n            }\n        }\n        return result;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.parseNestedParens(\"(()()) ((())) () ((())()())\").equals(Arrays.asList(2, 3, 1, 3)),\n                s.parseNestedParens(\"() (()) ((())) (((())))\").equals(Arrays.asList(1, 2, 3, 4)),\n                s.parseNestedParens(\"(()(())((())))\").equals(Arrays.asList(4))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parseNestedParens(\"(()()) ((())) () ((())()())\")\n    [2, 3, 1, 3]", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> parseNestedParens(String paren_string) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.parseNestedParens(\"(()()) ((())) () ((())()())\").equals(Arrays.asList(2, 3, 1, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three. ", "prompt_explain": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> parseNestedParens(\"(()()) ((())) () ((())()())\")\n[2, 3, 1, 3]", "func_title": "public List<Integer> parseNestedParens(String paren_string) ", "prediction": "         List<Integer> result = new ArrayList<>();\n         String[] groups = paren_string.split(\"\\\\s+\");\n         for (String group : groups) {\n             String[] parts = group.split(\"\\\\(|\\\\)\");\n             int level = Integer.parseInt(parts[0]);\n             for (int i = 1; i < parts.length; i++) {\n                 if (parts[i].equals(\")\")) {\n                     level--;\n                 } else {\n                     level++;\n                 }\n             }\n             result.add(level);\n         }\n         return result;\n     }"}
{"task_id": "Java/7", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Filter an input list of strings only for ones that contain given substring\n    >>> filterBySubstring(List.of(), \"a\")\n    []\n    >>> filterBySubstring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n     */\n    public List<String> filterBySubstring(List<String> strings, String substring) {\n", "canonical_solution": "        List<String> result = new ArrayList<>();\n        for (String x : strings) {\n            if (x.contains(substring)) {\n                result.add(x);\n            }\n        }\n        return result;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.filterBySubstring(new ArrayList<>(List.of()), \"john\").equals(List.of()),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), \"xxx\").equals(Arrays.asList(\"xxx\", \"xxxAAA\", \"xxx\")),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\")), \"xx\").equals(Arrays.asList(\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\")),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"grunt\", \"trumpet\", \"prune\", \"gruesome\")), \"run\").equals(Arrays.asList(\"grunt\", \"prune\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    Filter an input list of strings only for ones that contain given substring\n    >>> filterBySubstring(List.of(), \"a\")\n    []\n    >>> filterBySubstring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n    [\"abc\", \"bacd\", \"array\"]", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> filterBySubstring(List<String> strings, String substring) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.filterBySubstring(new ArrayList<>(List.of()), \"s\").equals(List.of()),\n                s.filterBySubstring(new ArrayList<>(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\")), \"a\").equals(Arrays.asList(\"abc\", \"bacd\", \"array\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "Filter an input list of strings only for ones that contain given substring", "prompt_explain": "Filter an input list of strings only for ones that contain given substring\n>>> filterBySubstring(List.of(), \"a\")\n[]\n>>> filterBySubstring(Arrays.asList(\"abc\", \"bacd\", \"cde\", \"array\"), \"a\")\n[\"abc\", \"bacd\", \"array\"]", "func_title": "public List<String> filterBySubstring(List<String> strings, String substring) ", "prediction": "         if (strings == null || strings.isEmpty()) {\n             return new ArrayList<>();\n         }\n         List<String> result = new ArrayList<>();\n         for (String s : strings) {\n             if (s.contains(substring)) {\n                 result.add(s);\n             }\n         }\n         return result;\n     }"}
{"task_id": "Java/8", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sumProduct(List.of())\n    [0, 1]\n    >>> sumProduct(Arrays.asList(1, 2, 3, 4))\n    [10, 24]\n     */\n    public List<Integer> sumProduct(List<Integer> numbers) {\n", "canonical_solution": "        int sum = 0;\n        int product = 1;\n\n        for (int n : numbers) {\n            sum += n;\n            product *= n;\n        }\n        return Arrays.asList(sum, product);\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumProduct(new ArrayList<>(List.of())).equals(Arrays.asList(0, 1)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(1, 1, 1))).equals(Arrays.asList(3, 1)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(100, 0))).equals(Arrays.asList(100, 0)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(3, 5, 7))).equals(Arrays.asList(3 + 5 + 7, 3 * 5 * 7)),\n                s.sumProduct(new ArrayList<>(List.of(10))).equals(Arrays.asList(10, 10))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sumProduct(List.of())\n    [0, 1]\n    >>> sumProduct(Arrays.asList(1, 2, 3, 4))\n    [10, 24]", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> sumProduct(List<Integer> numbers) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumProduct(new ArrayList<>(List.of())).equals(Arrays.asList(0, 1)),\n                s.sumProduct(new ArrayList<>(Arrays.asList(1, 2, 3,4))).equals(Arrays.asList(10, 24))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.", "prompt_explain": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> sumProduct(List.of())\n[0, 1]\n>>> sumProduct(Arrays.asList(1, 2, 3, 4))\n[10, 24]", "func_title": "public List<Integer> sumProduct(List<Integer> numbers) ", "prediction": "         List<Integer> result = new ArrayList<>();\n         for (int num : numbers) {\n             result.add(num);\n             result.add(num * num);\n         }\n         return result;\n     }"}
{"task_id": "Java/9", "predictions": [""], "references": [""], "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rollingMax(List<Integer> numbers) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        if (numbers.size() == 0) {\n            return result;\n        }\n        int rollingMax = numbers.get(0);\n        result.add(rollingMax);\n\n        for (int i = 1; i < numbers.size(); i++) {\n            if (numbers.get(i) > rollingMax) {\n                rollingMax = numbers.get(i);\n            }\n            result.add(rollingMax);\n        }\n\n        return result;\n    }\n}", "test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rollingMax(new ArrayList<>(List.of())).equals(List.of()),\n                s.rollingMax(new ArrayList<>(Arrays.asList(1, 2, 3, 4))).equals(Arrays.asList(1, 2, 3, 4)),\n                s.rollingMax(new ArrayList<>(Arrays.asList(4, 3, 2, 1))).equals(Arrays.asList(4, 4, 4, 4)),\n                s.rollingMax(new ArrayList<>(Arrays.asList(3, 2, 3, 100, 3))).equals(Arrays.asList(3, 3, 3, 100, 100))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "text": "    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> rollingMax(List<Integer> numbers) {\n", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rollingMax(new ArrayList<>(List.of(1, 2, 3, 2, 3, 4, 2))).equals(List.of(1, 2, 3, 3, 3, 4, 4))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "prompt_text": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.", "prompt_explain": "From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n[1, 2, 3, 3, 3, 4, 4]", "func_title": "public List<Integer> rollingMax(List<Integer> numbers) ", "prediction": "         if (numbers.isEmpty()) {\n             return new ArrayList<>();\n         }\n         int max = numbers.get(0);\n         List<Integer> result = new ArrayList<>();\n         for (int i = 1; i < numbers.size(); i++) {\n             if (numbers.get(i) > max) {\n                 max = numbers.get(i);\n                 result.add(max);\n             }\n         }\n         return result;\n     }"}
{"task_id": "Go/0", "predictions": [""], "references": [""], "prompt": "import (\n    \"math\"\n)\n\n// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n// >>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\n// false\n// >>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\n// true\n", "declaration": "\nfunc HasCloseElements(numbers []float64, threshold float64) bool {\n", "canonical_solution": "    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++ {\n            var distance float64 = math.Abs(numbers[i] - numbers[j])\n            if distance < threshold {\n                return true\n            }\n        }\n    }\n    return false\n}\n\n", "test": "func TestHasCloseElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, HasCloseElements([]float64{11.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3))\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.95))\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 5.9, 4.0, 5.0}, 0.8))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}, 0.1))\n    assert.Equal(true, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 1.0))\n    assert.Equal(false, HasCloseElements([]float64{1.1, 2.2, 3.1, 4.1, 5.1}, 0.5))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestHasCloseElements(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5))\n    assert.Equal(true, HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3))\n}\n", "prompt_text": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.", "prompt_explain": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n>>> HasCloseElements([]float64{1.0, 2.0, 3.0}, 0.5)\nfalse\n>>> HasCloseElements([]float64{1.0, 2.8, 3.0, 4.0, 5.0, 2.0}, 0.3)\ntrue\n", "func_title": "func HasCloseElements(numbers []float64, threshold float64) bool ", "prediction": " for i := 0; i < len(numbers); i++ {\n     for j := i + 1; j < len(numbers); j++ {\n         if math.Abs(numbers[i]-numbers[j]) <= threshold {\n             return true\n         }\n     }\n }\n return false\n }"}
{"task_id": "Go/1", "predictions": [""], "references": [""], "prompt": "\n// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\nfunc SeparateParenGroups(paren_string string) []string {\n", "import": "", "docstring": "// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the list of those.\n// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\n// >>> SeparateParenGroups('( ) (( )) (( )( ))')\n// ['()', '(())', '(()())']\n", "declaration": "\nfunc SeparateParenGroups(paren_string string) []string {\n", "canonical_solution": "    result := make([]string, 0)\n    current_string := make([]rune, 0)\n    current_depth := 0\n\n    for _, c := range paren_string {\n        if c == '(' {\n            current_depth += 1\n            current_string = append(current_string, c)\n        }else if c== ')'{\n            current_depth -= 1\n            current_string = append(current_string, c)\n\n            if current_depth == 0{\n                result = append(result, string(current_string))\n                current_string =  make([]rune, 0)\n            }\n        }\n\n    }\n    return result\n}\n\n", "test": "func TestSeparateParenGroups(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"(()())\", \"((()))\", \"()\", \"((())()())\"}, SeparateParenGroups(\"(()()) ((())) () ((())()())\"))\n    assert.Equal([]string{\"()\", \"(())\", \"((()))\", \"(((())))\"}, SeparateParenGroups(\"() (()) ((())) (((())))\"))\n    assert.Equal([]string{\"(()(())((())))\"}, SeparateParenGroups(\"(()(())((())))\"))\n    assert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSeparateParenGroups(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{\"()\", \"(())\", \"(()())\"}, SeparateParenGroups(\"( ) (( )) (( )( ))\"))\n}\n", "prompt_text": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.", "prompt_explain": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> SeparateParenGroups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\n", "func_title": "func SeparateParenGroups(paren_string string) []string ", "prediction": "\n // Create a slice to store the result\n result := make([]string, 0)\n\n // Create a loop to iterate through the input string\n for i := 0; i < len(paren_string); i++ {\n\n     // Check if the current character is a closing brace\n     if paren_string[i] == ')' {\n\n         // If the current character is the last character of the group, add it to the result\n         if i == len(paren_string)-1 {\n             result = append(result, paren_string[i:])\n         }\n\n         // If the current character is not the last character of the group, skip it\n         continue\n     }\n\n     // If the current character is not a closing brace, it must be a nested group\n     nested_group := true\n     for j := i + 1; j < len(paren_string); j++ {\n         if paren_string[j] == ')' {\n             nested_group = false\n             break\n         }\n     }\n\n     // If the current character is not a closing brace and it is not the first character of a nested group, skip it\n     if nested_group {\n         continue\n     }\n\n     // If the current character is not a closing brace and it is the first character of a nested group, add it to the result\n     if nested_group && j == len(paren_string)-1 {\n         result = append(result, paren_string[i:j])\n     }\n }\n\n return result\n\n }"}
{"task_id": "Go/2", "predictions": [""], "references": [""], "prompt": "import (\n    \"math\"\n)\n\n// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\nfunc TruncateNumber(number float64) float64 {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// Given a positive floating point number, it can be decomposed into\n// and integer part (largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n// \n// Return the decimal part of the number.\n// >>> TruncateNumber(3.5)\n// 0.5\n", "declaration": "\nfunc TruncateNumber(number float64) float64 {\n", "canonical_solution": "    return math.Mod(number,1)\n}\n\n", "test": "func TestTruncateNumber(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0.5, TruncateNumber(3.5))\n    assert.Equal(true, math.Abs(TruncateNumber(1.33)-0.33) < 1e-6)\n    assert.Equal(true, math.Abs(TruncateNumber(123.456)-0.456) < 1e-6)\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestTruncateNumber(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(0.5, TruncateNumber(3.5))\n}\n", "prompt_text": "Given a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).  Return the decimal part of the number.", "prompt_explain": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> TruncateNumber(3.5)\n0.5\n", "func_title": "func TruncateNumber(number float64) float64 ", "prediction": " return math.Floor(number) - math.Floor(number/float64(math.Pow(10,len(strconv.FormatFloat(number, 'f', 'round'))-1)))\n }"}
{"task_id": "Go/3", "predictions": [""], "references": [""], "prompt": "\n// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\nfunc BelowZero(operations []int) bool {\n", "import": "", "docstring": "// You're given a list of deposit and withdrawal operations on a bank account that starts with\n// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n// at that point function should return true. Otherwise it should return false.\n// >>> BelowZero([1, 2, 3])\n// false\n// >>> BelowZero([1, 2, -4, 5])\n// true\n", "declaration": "\nfunc BelowZero(operations []int) bool {\n", "canonical_solution": "    balance := 0\n    for _, op := range operations {\n        balance += op\n        if balance < 0 {\n            return true\n        }\n    }\n    return false\n}\n\n", "test": "func TestBelowZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, BelowZero([]int{}))\n    assert.Equal(false, BelowZero([]int{1, 2, -3, 1, 2, -3}))\n    assert.Equal(true, BelowZero([]int{1, 2, -4, 5, 6}))\n    assert.Equal(false, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -4}))\n    assert.Equal(true, BelowZero([]int{1, -1, 2, -2, 5, -5, 4, -5}))\n    assert.Equal(true, BelowZero([]int{1, -2, 2, -2, 5, -5, 4, -4}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestBelowZero(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(false, BelowZero([]int{1, 2, 3}))\n    assert.Equal(true, BelowZero([]int{1, 2, -4, 5}))\n}\n", "prompt_text": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return true. Otherwise it should return false.", "prompt_explain": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return true. Otherwise it should return false.\n>>> BelowZero([1, 2, 3])\nfalse\n>>> BelowZero([1, 2, -4, 5])\ntrue\n", "func_title": "func BelowZero(operations []int) bool ", "prediction": " for _, operation := range operations {\n     if operation < 0 {\n         return true\n     }\n }\n return false"}
{"task_id": "Go/4", "predictions": [""], "references": [""], "prompt": "import (\n    \"math\"\n)\n\n// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// For a given list of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint (mean in this case):\n// MAD = average | x - x_mean |\n// >>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n// 1.0\n", "declaration": "\nfunc MeanAbsoluteDeviation(numbers []float64) float64 {\n", "canonical_solution": "    sum := func(numbers []float64) float64 {\n        sum := 0.0\n        for _, num := range numbers {\n            sum += num\n        }\n        return sum\n    }\n\n    mean := sum(numbers) / float64(len(numbers))\n    numList := make([]float64, 0)\n    for _, x := range numbers {\n        numList = append(numList, math.Abs(x-mean))\n    }\n    return sum(numList) / float64(len(numbers))\n}\n\n", "test": "func TestMeanAbsoluteDeviation(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0})-2.0/3.0) < 1e-6)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0, 5.0})-6.0/5.0) < 1e-6)\n\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestMeanAbsoluteDeviation(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, math.Abs(MeanAbsoluteDeviation([]float64{1.0, 2.0, 3.0, 4.0})-1.0) < 1e-6)\n}\n", "prompt_text": "For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |", "prompt_explain": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> MeanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n1.0\n", "func_title": "func MeanAbsoluteDeviation(numbers []float64) float64 ", "prediction": " mean := math.Mean(numbers)\n var sum = 0\n for _, num := range numbers {\n     diff := math.Abs(num - mean)\n     sum += diff\n }\n return sum / len(numbers)\n}"}
{"task_id": "Go/5", "predictions": [""], "references": [""], "prompt": "\n// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\nfunc Intersperse(numbers []int, delimeter int) []int {\n", "import": "", "docstring": "// Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> Intersperse([], 4)\n// []\n// >>> Intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\n", "declaration": "\nfunc Intersperse(numbers []int, delimeter int) []int {\n", "canonical_solution": "    result := make([]int, 0)\n    if len(numbers) == 0 {\n        return result\n    }\n    for i := 0; i < len(numbers)-1; i++ {\n        n := numbers[i]\n        result = append(result, n)\n        result = append(result, delimeter)\n    }\n    result = append(result, numbers[len(numbers)-1])\n    return result\n}\n\n", "test": "func TestIntersperse(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, Intersperse([]int{}, 7))\n    assert.Equal([]int{5, 8, 6, 8, 3, 8, 2}, Intersperse([]int{5, 6, 3, 2}, 8))\n    assert.Equal([]int{2, 2, 2, 2, 2}, Intersperse([]int{2, 2, 2}, 2))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestIntersperse(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, Intersperse([]int{}, 4))\n    assert.Equal([]int{1,4,2,4,3}, Intersperse([]int{1,2,3}, 4))\n}\n", "prompt_text": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'", "prompt_explain": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n>>> Intersperse([], 4)\n[]\n>>> Intersperse([1, 2, 3], 4)\n[1, 4, 2, 4, 3]\n", "func_title": "func Intersperse(numbers []int, delimeter int) []int ", "prediction": " if len(numbers) == 0 {\n     return []int{}\n }\n\n // Create a new slice with the same length as the input slice\n newNumbers := make([]int, len(numbers))\n\n // Iterate over the input slice\n for i := 0; i < len(numbers); i += 2 {\n     // Get the two elements at the current index\n     currentElement := numbers[i]\n     nextElement := numbers[i+1]\n\n     // Insert the delimeter between the two elements\n     newNumbers[i] = currentElement + delimeter\n     newNumbers[i+1] = nextElement + delimeter\n }\n\n return newNumbers\n }"}
{"task_id": "Go/6", "predictions": [""], "references": [""], "prompt": "import (\n    \"math\"\n    \"strings\"\n)\n\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// \n// >>> ParseNestedParens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nfunc ParseNestedParens(paren_string string) []int {\n", "import": "import (\n    \"math\"\n    \"strings\"\n)\n", "docstring": "// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// \n// >>> ParseNestedParens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\n", "declaration": "\nfunc ParseNestedParens(paren_string string) []int {\n", "canonical_solution": "    parse_paren_group := func(s string) int {\n        depth := 0\n        max_depth := 0\n        for _, c := range s {\n            if c == '(' {\n                depth += 1\n                max_depth = int(math.Max(float64(depth), float64(max_depth)))\n            } else {\n                depth -= 1\n            }\n        }\n        return max_depth\n    }\n    result := make([]int, 0)\n    for _, x := range strings.Split(paren_string, \" \") {\n        result = append(result, parse_paren_group(x))\n    }\n    return result\n\n}\n\n", "test": "func TestParseNestedParens(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3, 1, 3}, ParseNestedParens(\"(()()) ((())) () ((())()())\"))\n    assert.Equal([]int{1, 2, 3, 4}, ParseNestedParens(\"() (()) ((())) (((())))\"))\n    assert.Equal([]int{4}, ParseNestedParens(\"(()(())((())))\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestParseNestedParens(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 3, 1, 3}, ParseNestedParens(\"(()()) ((())) () ((())()())\"))\n}\n", "prompt_text": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three. ", "prompt_explain": "Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\nFor each of the group, output the deepest level of nesting of parentheses.\nE.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n>>> ParseNestedParens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\n", "func_title": "func ParseNestedParens(paren_string string) []int ", "prediction": " // Split the input string by spaces\n paren_strings := strings.Split(paren_string, \" \")\n\n // Initialize an empty slice to store the deepest level of nesting of parentheses\n nested_parens := []int{}\n\n // Iterate over the input strings\n for _, paren_string := range paren_strings {\n     // Split the input string by spaces\n     paren_strings := strings.Split(paren_string, \" \")\n\n     // Initialize a map to store the deepest level of nesting of parentheses\n     nested_parens = append(nested_parens, 0)\n\n     // Iterate over the input strings\n     for _, nested_string := range paren_strings {\n         // Split the input string by spaces\n         nested_strings := strings.Split(nested_string, \" \")\n\n         // Initialize a map to store the deepest level of nesting of parentheses\n         nested_parens = append(nested_parens, 0)\n\n         // Iterate over the input strings\n         for _, nested_string := range nested_strings {\n             // Split the input string by spaces\n             nested_strings := strings.Split(nested_string, \" \")\n\n             // Iterate over the input strings\n             for _, nested_string := range nested_strings {\n                 // Initialize a map to store the deepest level of nesting of parentheses\n                 nested_parens = append(nested_parens, 0)\n\n                 // Iterate over the input strings\n                 for _, nested_string := range nested_strings {\n                     // Split the input string by spaces\n                     nested_strings := strings.Split(nested_string, \" \")\n\n                     // Iterate over the input strings\n                     for _, nested_string := range nested_strings {\n                         // Initialize a map to store the deepest level of nesting of parentheses\n                         nested_parens = append(nested_parens, 0)\n\n                         // Iterate over the input strings\n                         for _, nested_string := range nested_strings {\n                             // Initialize a map to store the deepest level of nesting of parentheses\n                             nested_parens = append(nested_parens, 0)\n\n                             // Iterate over the input strings\n                             for _, nested_string := range nested_strings {\n                                 // Initialize a map to store the deepest level of nesting of parentheses\n                                 nested_parens = append(nested_parens, 0)\n\n                                 // Iterate over the input strings\n                                 for _, nested_string := range nested_strings {\n                                     // Initialize a map to store the deepest level of nesting of parentheses\n                                     nested_parens = append(nested_parens, 0)\n\n                                     // Iterate over the input strings\n                                     for _, nested_string := range nested_strings {\n                                         // Initialize a map to store the deepest level of nesting of parentheses\n                                         nested_parens = append(nested_parens, 0)\n\n                                         // Iterate over the input strings\n                                         for _, nested_string :="}
{"task_id": "Go/7", "predictions": [""], "references": [""], "prompt": "import (\n    \"strings\"\n)\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> FilterBySubstring([], 'a')\n// []\n// >>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nfunc FilterBySubstring(stringList []string, substring string) []string {\n", "import": "import (\n    \"strings\"\n)\n", "docstring": "// Filter an input list of strings only for ones that contain given substring\n// >>> FilterBySubstring([], 'a')\n// []\n// >>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\n", "declaration": "\nfunc FilterBySubstring(stringList []string, substring string) []string {\n", "canonical_solution": "    result := make([]string, 0)\n    for _, x := range stringList {\n        if strings.Index(x, substring) != -1 {\n            result = append(result, x)\n        }\n    }\n    return result\n}\n\n", "test": "func TestFilterBySubstring(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, FilterBySubstring([]string{}, \"john\"))\n    assert.Equal([]string{\"xxx\", \"xxxAAA\", \"xxx\"}, FilterBySubstring([]string{\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xxx\"))\n    assert.Equal([]string{\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"}, FilterBySubstring([]string{\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"}, \"xx\"))\n    assert.Equal([]string{\"grunt\", \"prune\"}, FilterBySubstring([]string{\"grunt\", \"trumpet\", \"prune\", \"gruesome\"}, \"run\"))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestFilterBySubstring(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]string{}, FilterBySubstring([]string{}, \"a\"))\n    assert.Equal([]string{\"abc\", \"bacd\", \"array\"}, FilterBySubstring([]string{\"abc\", \"bacd\", \"cde\", \"array\"}, \"a\"))\n}\n", "prompt_text": "Filter an input list of strings only for ones that contain given substring", "prompt_explain": "Filter an input list of strings only for ones that contain given substring\n>>> FilterBySubstring([], 'a')\n[]\n>>> FilterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']\n", "func_title": "func FilterBySubstring(stringList []string, substring string) []string ", "prediction": " return strings.Contains(stringList, substring)\n }"}
{"task_id": "Go/8", "predictions": [""], "references": [""], "prompt": "\n// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> SumProduct([])\n// (0, 1)\n// >>> SumProduct([1, 2, 3, 4])\n// (10, 24)\nfunc SumProduct(numbers []int) [2]int {\n", "import": "", "docstring": "// For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\n// >>> SumProduct([])\n// (0, 1)\n// >>> SumProduct([1, 2, 3, 4])\n// (10, 24)\n", "declaration": "\nfunc SumProduct(numbers []int) [2]int {\n", "canonical_solution": "    sum_value := 0\n    prod_value := 1\n\n    for _, n := range numbers {\n        sum_value += n\n        prod_value *= n\n    }\n    return [2]int{sum_value, prod_value}\n}\n\n", "test": "func TestSumProduct(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{0, 1}, SumProduct([]int{}))\n    assert.Equal([2]int{3, 1}, SumProduct([]int{1, 1, 1}))\n    assert.Equal([2]int{100, 0}, SumProduct([]int{100, 0}))\n    assert.Equal([2]int{3 + 5 + 7, 3 * 5 * 7}, SumProduct([]int{3, 5, 7}))\n    assert.Equal([2]int{10, 10}, SumProduct([]int{10}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestSumProduct(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([2]int{0, 1}, SumProduct([]int{}))\n    assert.Equal([2]int{10,24}, SumProduct([]int{1, 2,3,4}))\n}\n", "prompt_text": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.", "prompt_explain": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\nEmpty sum should be equal to 0 and empty product should be equal to 1.\n>>> SumProduct([])\n(0, 1)\n>>> SumProduct([1, 2, 3, 4])\n(10, 24)\n", "func_title": "func SumProduct(numbers []int) [2]int ", "prediction": " if len(numbers) == 0 {\n     return [2]int{0, 1}\n }\n\n sum := 0\n product := 1\n\n for _, num := range numbers {\n     sum += num\n     product *= num\n }\n\n return [2]int{sum, product}"}
{"task_id": "Go/9", "predictions": [""], "references": [""], "prompt": "import (\n    \"math\"\n)\n\n// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nfunc RollingMax(numbers []int) []int {\n", "import": "import (\n    \"math\"\n)\n", "docstring": "// From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\n", "declaration": "\nfunc RollingMax(numbers []int) []int {\n", "canonical_solution": "    running_max := math.MinInt32\n    result := make([]int, 0)\n\n    for _, n := range numbers {\n        if running_max == math.MinInt32 {\n            running_max = n\n        } else {\n            running_max = int(math.Max(float64(running_max), float64(n)))\n        }\n        result = append(result, running_max)\n    }\n\n    return result\n}\n\n", "test": "func TestRollingMax(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{}, RollingMax([]int{}))\n    assert.Equal([]int{1, 2, 3, 4}, RollingMax([]int{1, 2, 3, 4}))\n    assert.Equal([]int{4, 4, 4, 4}, RollingMax([]int{4, 3, 2, 1}))\n    assert.Equal([]int{3, 3, 3, 100, 100}, RollingMax([]int{3, 2, 3, 100, 3}))\n}\n", "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n", "example_test": "func TestRollingMax(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{1, 2, 3,3, 3, 4, 4}, RollingMax([]int{1, 2, 3, 2, 3, 4, 2}))\n}\n", "prompt_text": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.", "prompt_explain": "From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> RollingMax([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n", "func_title": "func RollingMax(numbers []int) []int ", "prediction": " rollingMax := make([]int, len(numbers))\n\n for i := range numbers {\n     rollingMax[i] = numbers[i]\n }\n\n // Find the maximum element in the sequence\n maxIndex := 0\n for i := len(numbers) - 1; i >= 0; i-- {\n     if numbers[i] > rollingMax[maxIndex] {\n         rollingMax[maxIndex], rollingMax[i] = numbers[i], numbers[maxIndex]\n         maxIndex = i\n     }\n }\n\n return rollingMax\n }"}